#! /usr/bin/env ruby

# Initial color palette values
# This tries to approximate the 256-color xterm pallete,
# and gets pretty close, except that we don't have enough
# color intensities to do the full 24-step grayscale at
# the end of the palette, so there are some duplicate gray
# values.

# System colors

# Off/on values for non-intense colors
SYS_NON_INTENSE = [ 0x0, 0xA ]

# Off/on values for intense colors
SYS_INTENSE = [ 0x5, 0xF ]

def add_sys_colors(colors, component_intensity)
  (0..7).each do |x|
    # in xterm system colors, r is bit 1, g is bit 2, b is bit 3
    # (which is the reverse of CGA/EGA/VGA)
    r = ((x & 0x1) != 0) ? 1 : 0
    g = ((x & 0x2) != 0) ? 1 : 0
    b = ((x & 0x4) != 0) ? 1 : 0
    # we define a color as being a 16-bit xxxxRRRRGGGGBBBB value
    value = (component_intensity[r] << 8) | (component_intensity[g] << 4) | component_intensity[b]
    # add to palette
    colors.push(value)
  end
end

# intensity values for the 6x6x6 color cube
CUBE_INTENSITY = [ 0, 3, 6, 9, 12, 15 ]

colors = []

# Generate system colors
add_sys_colors(colors, SYS_NON_INTENSE)
add_sys_colors(colors, SYS_INTENSE)

# Generate 6x6x6 RGB color cube
(0..5).each do |r|
  (0..5).each do |g|
    (0..5).each do |b|
      value = (CUBE_INTENSITY[r] << 8) | (CUBE_INTENSITY[g] << 4) | CUBE_INTENSITY[b]
      colors.push(value)
    end
  end
end

# Generate 24-step grayscale (as close as we can get, anyway)
(0..23).each do |i|
  intensity = ((i / 24.0) * 16.0).round.to_i
  value = (intensity << 8) | (intensity << 4) | intensity
  colors.push(value)
end

puts "// Generated by gen_init_palette_data.rb"
puts ""

(0..colors.length-1).each do |i|
  puts "color_data[8'd#{i}] = 16'd#{colors[i]};"
end

puts ""
s = "vim"
puts "// #{s}:ft=verilog:"
